<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>üêµ BTD6 Social ‚Äî Server-stored profiles/posts</title>
<style>
  :root { --bg:#121212; --card:#1a1a1a; --accent:#f6b93b; --muted:#999; }
  body{font-family:"Segoe UI",Arial,sans-serif;background:var(--bg);color:#fff;margin:0}
  header{display:flex;align-items:center;justify-content:space-between;background:#2d2d2d;padding:10px 18px;color:var(--accent);font-weight:700}
  header .brand{font-size:1.2em}
  header .userPanel{font-size:0.95em}
  #navTabs{display:flex;justify-content:center;gap:12px;background:#1e1e1e;padding:10px 0}
  #navTabs button{background:none;border:none;color:var(--accent);font-weight:700;cursor:pointer;padding:6px 12px;border-radius:6px}
  #navTabs button.active{background:#2a2e50;color:#fff}
  #contentArea{max-width:900px;margin:18px auto;padding:14px;border-radius:10px;background:var(--card);box-shadow:0 8px 30px rgba(0,0,0,0.5)}
  .feedPost{background:#161618;border-radius:8px;padding:12px;margin-bottom:14px;display:block}
  .postHeader{display:flex;align-items:center;gap:12px;margin-bottom:6px}
  .avatar{width:44px;height:44px;border-radius:50%;object-fit:cover;border:2px solid #222;flex:0 0 44px}
  .authorName{font-weight:700;color:#f6b93b}
  .feedPost img.media{max-width:100%;border-radius:8px;margin-top:8px}
  .small{color:var(--muted);font-size:0.9em}
  button.action{background:var(--accent);border:none;padding:6px 10px;border-radius:6px;cursor:pointer;margin-right:6px;color:#000;font-weight:700}
  button.danger{background:#e74c3c;color:#fff}
  textarea,input[type=text],input[type=password]{width:100%;padding:8px;border-radius:6px;border:none;background:#0f1116;color:#fff;box-sizing:border-box}
  ul.simple{list-style:none;padding:0;margin:0}
  .smallBtn{background:#2b2b2b;border:1px solid #333;padding:6px 8px;border-radius:6px;color:#fff;cursor:pointer}
  /* Auth overlay */
  #authOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:999}
  .authCard{width:360px;background:#141416;padding:18px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.7)}
  .authCard h3{margin:0 0 10px 0;color:var(--accent)}
  .authRow{margin-bottom:8px}
  .linkish{color:#4da3ff;cursor:pointer;text-decoration:underline;font-size:0.95em}
  @media (max-width:880px){
    #contentArea{margin:12px}
    .authCard{width:92%}
    .postHeader{gap:8px}
    .avatar{width:36px;height:36px;flex:0 0 36px}
  }
</style>
</head>
<body>

<header>
  <div class="brand">üêµ BTD6 Social</div>
  <div class="userPanel">
    <span id="who">Not signed in</span>
    <button id="logoutBtn" class="smallBtn" style="display:none;margin-left:10px">Logout</button>
  </div>
</header>

<div id="navTabs" aria-hidden="false">
  <button data-tab="feed" class="active">Feed</button>
  <button data-tab="threads">Threads</button>
  <button data-tab="messages">Messages</button>
  <button data-tab="profile">Profile</button>
</div>

<div id="contentArea">Loading...</div>

<!-- Auth overlay -->
<div id="authOverlay" style="display:none">
  <div class="authCard">
    <div id="authForms">
      <!-- Login form -->
      <div id="loginForm">
        <h3>Welcome ‚Äî Sign In</h3>
        <div class="authRow"><input id="loginUser" placeholder="Username"></div>
        <div class="authRow"><input id="loginPass" type="password" placeholder="Password"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button class="action" onclick="doLogin()">Login</button>
          <button class="smallBtn" onclick="showRegister()">Register</button>
        </div>
        <p class="small" style="margin-top:10px">Don't have an account? <span class="linkish" onclick="showRegister()">Create one</span></p>
      </div>

      <!-- Register form -->
      <div id="registerForm" style="display:none">
        <h3>Create account</h3>
        <div class="authRow"><input id="regUser" placeholder="Choose username"></div>
        <div class="authRow"><input id="regPass" type="password" placeholder="Choose password"></div>
        <div class="authRow"><input id="regBio" placeholder="Short bio (optional)"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button class="action" onclick="doRegister()">Register</button>
          <button class="smallBtn" onclick="showLogin()">Back</button>
        </div>
        <p class="small" style="margin-top:10px">By registering you store this account on the server_data of the room.</p>
      </div>
    </div>
  </div>
</div>

<script>
/* ================== Configuration ================== */
/* SERVER: tunnel.txt must contain base URL like "https://example.com" (no trailing slash) */
let SERVER_URL = "";
const KEY = "5duM4W8HZiQBSU4v";
const ROOM = "btd6-social";

/* Storage keys (same names as you requested) */
const PROFILE_KEY = "btd6_profile";
const USERS_KEY = "btd6_users";
const LOCAL_POSTS = "btd6_localPosts";
const LOCAL_DMS = "btd6_localDMs"; // stays local

/* App state */
let currentUser = null; // will be object { username, password, bio, avatar }
let usersMap = {};      // map username -> { password, bio, avatar }
let allFeedPosts = [];  // merged posts (server static JSON + local posts)
let localPosts = [];    // posts we control (will be stored server-side under LOCAL_POSTS)

/* DOM helpers */
const el = s => document.querySelector(s);
const qAll = s => Array.from(document.querySelectorAll(s));
const saveLocal = (k,v) => localStorage.setItem(k, JSON.stringify(v));
const loadLocal = (k, fallback) => { try { return JSON.parse(localStorage.getItem(k)||"null") || fallback } catch(e){ return fallback } };

/* Escape helpers */
function escapeHtml(s){ if (s===undefined || s===null) return ""; return String(s).replace(/[&<>"']/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }
function escapeAttr(s){ return String(s).replace(/"/g,'&quot;'); }

/* ================== Server room helpers ================== */
async function loadConfig(){
  try {
    const r = await fetch("tunnel.txt");
    if (r.ok) {
      SERVER_URL = (await r.text()).trim();
      if (SERVER_URL.endsWith("/")) SERVER_URL = SERVER_URL.slice(0,-1);
      console.log("SERVER_URL =", SERVER_URL);
    }
  } catch(e){
    console.warn("tunnel.txt not found or failed to load.");
  }
}

/* fetch the full room JSON data (returns data object or throws) */
async function serverFetchRoom(){
  if (!SERVER_URL) throw new Error("SERVER_URL not configured");
  const res = await fetch(`${SERVER_URL}/room/${ROOM}?key=${KEY}`);
  if (!res.ok) throw new Error("server fetch failed");
  const json = await res.json();
  if (!json.ok) throw new Error("server returned not ok");
  return json.data || {};
}

/* save the whole room JSON (server expects full data for this endpoint) */
async function serverSaveRoom(data){
  if (!SERVER_URL) throw new Error("SERVER_URL not configured");
  const res = await fetch(`${SERVER_URL}/room/${ROOM}?key=${KEY}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data)
  });
  if (!res.ok) throw new Error("server save failed");
  // Attempt to parse response but not required
  try { return await res.json(); } catch(e){ return null; }
}

/* read a key from data.server_storage */
async function loadServerKey(keyName){
  try {
    const data = await serverFetchRoom();
    return (data.server_storage && data.server_storage[keyName]) ? data.server_storage[keyName] : null;
  } catch (e) {
    console.warn("loadServerKey failed:", keyName, e);
    return null;
  }
}

/* save a key into data.server_storage (fetch current room, patch server_storage, post) */
async function saveServerKey(keyName, value){
  try {
    const data = await serverFetchRoom();
    data.server_storage = data.server_storage || {};
    data.server_storage[keyName] = value;
    await serverSaveRoom(data);
    return true;
  } catch (e) {
    console.warn("saveServerKey failed:", keyName, e);
    return false;
  }
}

/* ========== Auth UI and logic ========== */
function showAuthOverlay(){ el("#authOverlay").style.display = "flex"; showLogin(); }
function hideAuthOverlay(){ el("#authOverlay").style.display = "none"; }
function showLogin(){ el("#loginForm").style.display = "block"; el("#registerForm").style.display = "none"; }
function showRegister(){ el("#loginForm").style.display = "none"; el("#registerForm").style.display = "block"; }

function setSignedInUI(){
  currentUser = currentUser || loadLocal(PROFILE_KEY, null);
  if (currentUser && currentUser.username){
    el("#who").textContent = "Signed in: @" + currentUser.username;
    el("#logoutBtn").style.display = "inline-block";
  } else {
    el("#who").textContent = "Not signed in";
    el("#logoutBtn").style.display = "none";
  }
}

/* Register: update usersMap and save to server and local */
async function doRegister(){
  const username = (el("#regUser").value || "").trim();
  const pass = (el("#regPass").value || "").trim();
  const bio = (el("#regBio").value || "").trim();
  if (!username || !pass) return alert("Enter username and password.");
  // ensure usersMap loaded
  usersMap = usersMap || loadLocal(USERS_KEY, {});
  if (usersMap[username]) return alert("Username taken. Choose another.");
  usersMap[username] = { password: pass, bio: bio || "", avatar: "" };
  // Save to server
  const ok = await saveServerKey(USERS_KEY, usersMap);
  if (!ok) {
    // fallback: save locally and inform user
    saveLocal(USERS_KEY, usersMap);
    alert("Registered locally but could not save to server (server unavailable).");
  } else {
    saveLocal(USERS_KEY, usersMap);
  }
  // set current user and save profile to server
  currentUser = { username, password: pass, bio: bio || "", avatar: "" };
  const profOK = await saveServerKey(PROFILE_KEY, currentUser);
  if (!profOK) {
    saveLocal(PROFILE_KEY, currentUser);
    alert("Signed up locally (server save failed).");
  } else {
    saveLocal(PROFILE_KEY, currentUser);
  }
  setSignedInUI();
  hideAuthOverlay();
  switchTab("feed");
  alert("Registered & signed in as @" + username);
}

/* Login: check usersMap (server first, then fallback to local) */
async function doLogin(){
  const username = (el("#loginUser").value || "").trim();
  const pass = (el("#loginPass").value || "").trim();
  if (!username || !pass) return alert("Enter username and password.");
  // Try server users first
  let serverUsers = await loadServerKey(USERS_KEY);
  if (serverUsers) {
    usersMap = serverUsers;
  } else {
    usersMap = loadLocal(USERS_KEY, {});
  }
  const u = usersMap[username];
  if (!u || u.password !== pass) return alert("Invalid username or password.");
  // load profile from server key if present
  const serverProfile = await loadServerKey(PROFILE_KEY);
  if (serverProfile && serverProfile.username === username) {
    currentUser = serverProfile;
    saveLocal(PROFILE_KEY, currentUser);
  } else {
    // create profile object from users map entry (keeps parity)
    currentUser = { username, password: pass, bio: u.bio || "", avatar: u.avatar || "" };
    saveLocal(PROFILE_KEY, currentUser);
    // try saving profile to server (best-effort)
    await saveServerKey(PROFILE_KEY, currentUser);
  }
  saveLocal(USERS_KEY, usersMap);
  setSignedInUI();
  hideAuthOverlay();
  switchTab("feed");
  alert("Signed in as @" + username);
}

function doLogout(){
  if (!confirm("Log out?")) return;
  currentUser = null;
  localStorage.removeItem(PROFILE_KEY);
  setSignedInUI();
  showAuthOverlay();
}
el("#logoutBtn").addEventListener("click", doLogout);

/* ensure signed in - overlay if not */
function ensureSignedIn(){
  currentUser = currentUser || loadLocal(PROFILE_KEY, null);
  if (!currentUser || !currentUser.username){
    showAuthOverlay();
    setSignedInUI();
    return false;
  }
  hideAuthOverlay();
  setSignedInUI();
  return true;
}

/* ================= Profile avatar helper ================== */
function getAvatarFor(username){
  if (!username) return 'https://via.placeholder.com/100';
  if (currentUser && currentUser.username === username && currentUser.avatar) return currentUser.avatar;
  const users = usersMap || loadLocal(USERS_KEY, {});
  if (users[username] && users[username].avatar) return users[username].avatar;
  return 'https://via.placeholder.com/100';
}

/* ================ Feed (local posts + static JSON) ================ */
async function loadFeed(){
  if (!ensureSignedIn()) return;
  await refreshFeed();
}

/* Refresh feed: load static btd6-social.json and localPosts (from server if available) */
async function refreshFeed(){
  const area = el("#contentArea");
  area.innerHTML = `<div class="feedPost"><div class="small">Loading feed...</div></div>`;
  // load server static JSON posts
  let serverPosts = [];
  try {
    const res = await fetch("btd6-social.json");
    if (res.ok) {
      const j = await res.json();
      serverPosts = j.posts || [];
    }
  } catch(e) { console.warn("Could not load btd6-social.json", e); }

  // load localPosts from server storage if available; fallback to localStorage
  let srvPosts = await loadServerKey(LOCAL_POSTS);
  if (Array.isArray(srvPosts)) {
    localPosts = srvPosts;
    saveLocal(LOCAL_POSTS, localPosts);
  } else {
    localPosts = loadLocal(LOCAL_POSTS, []);
  }

  // combine
  allFeedPosts = [...localPosts, ...serverPosts];
  renderFeed();
}

/* Render feed posts with avatars and click -> openPost */
function renderFeed(){
  const area = el("#contentArea");
  area.innerHTML = "";
  // create post composer
  const box = document.createElement("div"); box.className = "feedPost";
  box.innerHTML = `
    <h3>Create a Post</h3>
    <textarea id="newPostText" placeholder="What's on your mind?" style="height:70px"></textarea>
    <input id="newPostLink" placeholder="Optional link" style="margin-top:8px">
    <input type="file" id="newPostImage" accept="image/*" style="margin-top:8px">
    <div style="margin-top:8px"><button class="action" onclick="handleCreatePost()">Post</button></div>
  `;
  area.appendChild(box);

  // show posts newest-first
  allFeedPosts.sort((a,b)=>b.id - a.id);
  for (const p of allFeedPosts){
    const postEl = document.createElement("div"); postEl.className = "feedPost";

    // header with avatar + author
    const header = document.createElement("div"); header.className = "postHeader";
    const avatarImg = document.createElement("img"); avatarImg.className = "avatar";
    avatarImg.src = getAvatarFor(p.author);
    avatarImg.alt = p.author;
    avatarImg.onerror = ()=>{ avatarImg.src = 'https://via.placeholder.com/100'; };
    avatarImg.addEventListener("click", (e)=>{ e.stopPropagation(); openProfile(p.author); });

    const authorWrap = document.createElement("div");
    authorWrap.innerHTML = `<div class="authorName"><a href="#" onclick="openPost(${p.id});return false">@${escapeHtml(p.author)}</a></div><div class="small">${escapeHtml(p.time || "")}</div>`;
    header.appendChild(avatarImg);
    header.appendChild(authorWrap);
    postEl.appendChild(header);

    // body
    if (p.text) {
      const t = document.createElement("div"); t.innerHTML = `<p>${escapeHtml(p.text)}</p>`; postEl.appendChild(t);
    }
    if (p.image){
      const img = document.createElement("img"); img.className = "media"; img.src = p.image;
      img.onerror = ()=>{ /* ignore broken */ };
      postEl.appendChild(img);
    }
    if (p.link){
      const linkWrap = document.createElement("div"); linkWrap.innerHTML = `<p><a href="${escapeAttr(p.link)}" target="_blank">${escapeHtml(p.link)}</a></p>`;
      postEl.appendChild(linkWrap);
    }

    // actions
    const actions = document.createElement("div"); actions.style.marginTop = "8px";
    const likeBtn = document.createElement("button"); likeBtn.className="action"; likeBtn.textContent = `üëç ${ (p.likes||[]).length }`;
    likeBtn.addEventListener("click", e=>{ e.stopPropagation(); toggleLike(p.id,'like'); });
    const disBtn = document.createElement("button"); disBtn.className="action"; disBtn.textContent = `üëé ${ (p.dislikes||[]).length }`;
    disBtn.addEventListener("click", e=>{ e.stopPropagation(); toggleLike(p.id,'dislike'); });
    const comBtn = document.createElement("button"); comBtn.className="action"; comBtn.textContent = `üí¨ ${ (p.comments||[]).length }`;
    comBtn.addEventListener("click", e=>{ e.stopPropagation(); promptComment(p.id); });
    const shareBtn = document.createElement("button"); shareBtn.className="action"; shareBtn.textContent = "üîó Share";
    shareBtn.addEventListener("click", e=>{ e.stopPropagation(); sharePost(p.id); });
    actions.appendChild(likeBtn); actions.appendChild(disBtn); actions.appendChild(comBtn); actions.appendChild(shareBtn);
    if (p.author === (currentUser && currentUser.username ? currentUser.username : "You")){
      const del = document.createElement("button"); del.className="danger"; del.textContent="üóë Delete";
      del.addEventListener("click", e=>{ e.stopPropagation(); deletePost(p.id); });
      actions.appendChild(del);
    }
    postEl.appendChild(actions);

    // comments preview
    const cmWrap = document.createElement("div"); cmWrap.style.marginTop="6px"; cmWrap.style.borderTop="1px solid #333"; cmWrap.style.paddingTop="6px";
    if (p.comments && p.comments.length){
      p.comments.forEach(c=>{
        const cd = document.createElement("div"); cd.className="small"; cd.style.marginLeft="8px";
        cd.innerHTML = `<b>${escapeHtml(c.author)}</b>: ${escapeHtml(c.text)} <span class="small">(${escapeHtml(c.time||"")})</span>`;
        cmWrap.appendChild(cd);
      });
    }
    postEl.appendChild(cmWrap);

    // double-click opens standalone view
    postEl.addEventListener("dblclick", ()=> openPost(p.id));

    area.appendChild(postEl);
  }
}

/* Create post: save to server key LOCAL_POSTS, fallback to localStorage */
async function handleCreatePost(){
  if (!ensureSignedIn()) return;
  const text = el("#newPostText").value.trim();
  const link = el("#newPostLink").value.trim();
  const file = el("#newPostImage").files[0];
  if (!text && !link && !file) return alert("Write or attach something first.");
  const post = { id: Date.now(), author: currentUser.username || "You", text, link, image: "", time: new Date().toLocaleString(), likes: [], dislikes: [], comments: [] };
  if (file) post.image = await fileToDataURL(file);
  // push to localPosts array and attempt to save server-side
  localPosts = localPosts || loadLocal(LOCAL_POSTS, []);
  localPosts.unshift(post); // newest first
  const ok = await saveServerKey(LOCAL_POSTS, localPosts);
  if (!ok) {
    // fallback: save locally
    saveLocal(LOCAL_POSTS, localPosts);
    alert("Post saved locally, but failed to save to server (server unavailable).");
  } else {
    saveLocal(LOCAL_POSTS, localPosts);
  }
  await refreshFeed();
  el("#newPostText").value = ""; el("#newPostLink").value=""; el("#newPostImage").value="";
}

/* Helper: File to data URL */
function fileToDataURL(file){
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result);
    r.onerror = e => rej(e);
    r.readAsDataURL(file);
  });
}

/* Like/dislike/comment/delete/share helpers (update localPosts & server) */
async function persistLocalPostsToServer(){
  try { await saveServerKey(LOCAL_POSTS, localPosts); saveLocal(LOCAL_POSTS, localPosts); return true; }
  catch (e) { saveLocal(LOCAL_POSTS, localPosts); return false; }
}

function toggleLike(id,type){
  const me = currentUser && currentUser.username ? currentUser.username : "You";
  // modify in-place in localPosts if present, otherwise modify in allFeedPosts (if static server post, we don't save)
  let p = localPosts.find(x=>x.id===id);
  if (!p) p = allFeedPosts.find(x=>x.id===id);
  if (!p) return;
  p.likes = p.likes || []; p.dislikes = p.dislikes || [];
  if (type==="like"){ if (p.likes.includes(me)) p.likes = p.likes.filter(u=>u!==me); else { p.likes.push(me); p.dislikes = p.dislikes.filter(u=>u!==me); } }
  else { if (p.dislikes.includes(me)) p.dislikes = p.dislikes.filter(u=>u!==me); else { p.dislikes.push(me); p.likes = p.likes.filter(u=>u!==me); } }
  // persist changes if post is part of localPosts
  if (localPosts.find(x=>x.id===id)){
    persistLocalPostsToServer().then(ok=>{ if(!ok) console.warn("Failed to persist likes to server"); });
  }
  renderFeed();
}

function promptComment(id){
  const t = prompt("Enter comment:");
  if (!t) return;
  let p = localPosts.find(x=>x.id===id);
  if (!p) p = allFeedPosts.find(x=>x.id===id);
  if (!p) return;
  p.comments = p.comments || [];
  p.comments.push({ author: currentUser.username || "You", text: t, time: new Date().toLocaleTimeString() });
  if (localPosts.find(x=>x.id===id)){
    persistLocalPostsToServer().then(ok=>{ if(!ok) console.warn("Failed to persist comments to server"); });
  }
  renderFeed();
}

function deletePost(id){
  if (!confirm("Delete this post?")) return;
  // remove from localPosts if present and persist server-side
  localPosts = localPosts.filter(p => p.id !== id);
  persistLocalPostsToServer().then(ok=>{
    if (!ok) alert("Deleted locally but failed to update server.");
  });
  allFeedPosts = allFeedPosts.filter(p => p.id !== id);
  renderFeed();
}

function sharePost(id){
  const url = window.location.origin + window.location.pathname + "?post=" + id;
  navigator.clipboard.writeText(url).then(()=> alert("Link copied!"), ()=> alert("Could not copy link."));
}

/* Standalone post view */
function openPost(id){
  const p = allFeedPosts.find(x => x.id === id);
  if (!p) return alert("Post not found");
  history.replaceState({}, "", window.location.pathname + "?post=" + id);
  const area = el("#contentArea"); area.innerHTML = "";
  const postEl = document.createElement("div"); postEl.className = "feedPost";

  // header
  const header = document.createElement("div"); header.className = "postHeader";
  const avatarImg = document.createElement("img"); avatarImg.className = "avatar";
  avatarImg.src = getAvatarFor(p.author); avatarImg.onerror = ()=>{ avatarImg.src = 'https://via.placeholder.com/100'; };
  const authorWrap = document.createElement("div");
  authorWrap.innerHTML = `<div class="authorName">@${escapeHtml(p.author)}</div><div class="small">${escapeHtml(p.time || "")}</div>`;
  header.appendChild(avatarImg); header.appendChild(authorWrap); postEl.appendChild(header);

  if (p.text) postEl.appendChild(Object.assign(document.createElement("div"), { innerHTML: `<p>${escapeHtml(p.text)}</p>` }));
  if (p.image){
    const img = document.createElement("img"); img.className="media"; img.src = p.image; postEl.appendChild(img);
  }
  if (p.link) postEl.appendChild(Object.assign(document.createElement("div"), { innerHTML: `<p><a href="${escapeAttr(p.link)}" target="_blank">${escapeHtml(p.link)}</a></p>` }));

  // actions
  const actions = document.createElement("div"); actions.style.marginTop = "8px";
  const backBtn = document.createElement("button"); backBtn.className="smallBtn"; backBtn.textContent = "‚Üê Back";
  backBtn.addEventListener("click", ()=> { history.replaceState({}, "", window.location.pathname); refreshFeed(); });
  const likeBtn = document.createElement("button"); likeBtn.className="action"; likeBtn.textContent = `üëç ${ (p.likes||[]).length }`;
  likeBtn.addEventListener("click", ()=> toggleLike(p.id,'like'));
  const disBtn = document.createElement("button"); disBtn.className="action"; disBtn.textContent = `üëé ${ (p.dislikes||[]).length }`;
  disBtn.addEventListener("click", ()=> toggleLike(p.id,'dislike'));
  const comBtn = document.createElement("button"); comBtn.className="action"; comBtn.textContent = `üí¨ ${ (p.comments||[]).length }`;
  comBtn.addEventListener("click", ()=> promptComment(p.id));
  const shareBtn = document.createElement("button"); shareBtn.className="action"; shareBtn.textContent = "üîó Share";
  shareBtn.addEventListener("click", ()=> sharePost(p.id));
  actions.appendChild(backBtn); actions.appendChild(likeBtn); actions.appendChild(disBtn); actions.appendChild(comBtn); actions.appendChild(shareBtn);
  if (p.author === (currentUser && currentUser.username ? currentUser.username : "You")){
    const del = document.createElement("button"); del.className="danger"; del.textContent="üóë Delete";
    del.addEventListener("click", ()=> { if (confirm("Delete this post?")) { deletePost(p.id); history.replaceState({}, "", window.location.pathname); refreshFeed(); }});
    actions.appendChild(del);
  }
  postEl.appendChild(actions);

  // comments
  const commentsWrap = document.createElement("div"); commentsWrap.style.marginTop="10px"; commentsWrap.innerHTML = `<h4>Comments</h4>`;
  if (p.comments && p.comments.length){
    p.comments.forEach(c=>{
      const cd = document.createElement("div"); cd.className="small"; cd.style.marginBottom="6px";
      cd.innerHTML = `<b>${escapeHtml(c.author)}</b>: ${escapeHtml(c.text)} <div class="small">${escapeHtml(c.time||"")}</div>`;
      commentsWrap.appendChild(cd);
    });
  } else {
    const none = document.createElement("div"); none.className="small"; none.textContent = "No comments yet.";
    commentsWrap.appendChild(none);
  }
  const commentBox = document.createElement("div"); commentBox.style.marginTop="8px";
  commentBox.innerHTML = `<input id="singlePostComment" placeholder="Write a comment..." style="width:70%"><button class="action" id="singlePostCommentBtn">Post</button>`;
  commentBox.querySelector("#singlePostCommentBtn").addEventListener("click", ()=> {
    const txt = commentBox.querySelector("#singlePostComment").value.trim();
    if (!txt) return alert("Write a comment");
    p.comments = p.comments || [];
    p.comments.push({ author: currentUser.username || "You", text: txt, time: new Date().toLocaleTimeString() });
    // persist if local post
    const idx = localPosts.findIndex(x=>x.id===p.id);
    if (idx >= 0) { localPosts[idx] = p; persistLocalPostsToServer(); }
    openPost(p.id);
  });
  postEl.appendChild(commentsWrap); postEl.appendChild(commentBox);
  el("#contentArea").appendChild(postEl);
}

/* =============== Threads (server-synced, no auto refresh) =============== */
async function loadThreads(){
  if (!ensureSignedIn()) return;
  await refreshThreads();
}
async function refreshThreads(){
  const area = el("#contentArea"); area.innerHTML = `<div class="feedPost"><div class="small">Loading threads...</div></div>`;
  if (!SERVER_URL) { area.innerHTML = `<div class="feedPost"><div class="small">Server not configured (tunnel.txt missing)</div></div>`; return; }
  try {
    const data = await serverFetchRoom();
    const threads = data.threads || [];
    renderThreads(threads);
  } catch(e){
    console.warn("Failed to load threads:", e);
    area.innerHTML = `<div class="feedPost"><div class="small">‚ö†Ô∏è Could not reach server for threads.</div></div>`;
  }
}
function renderThreads(threads){
  const area = el("#contentArea");
  area.innerHTML = `
    <div class="feedPost">
      <h3>Create a Thread</h3>
      <input id="threadTitle" placeholder="Thread title" style="margin-top:8px">
      <textarea id="threadBody" placeholder="Thread content" style="height:70px;margin-top:8px"></textarea>
      <div style="margin-top:8px"><button class="action" onclick="createThread()">Create</button></div>
    </div>
  `;
  threads.sort((a,b)=>b.id - a.id);
  threads.forEach(t=>{
    const d = document.createElement("div"); d.className = "feedPost";
    let inner = `<h4>${escapeHtml(t.title)}</h4><div class="small">by ${escapeHtml(t.author)}${t.time ? " ‚Ä¢ " + escapeHtml(t.time) : ""}</div>`;
    if (t.text) inner += `<p>${escapeHtml(t.text)}</p>`;
    inner += `<div style="margin-top:8px"><button class="action" onclick="replyThread(${t.id})">üí¨ ${ (t.replies||[]).length }</button></div>`;
    if (t.replies && t.replies.length){
      inner += `<div style="margin-top:8px;border-top:1px solid #333;padding-top:6px">`;
      t.replies.forEach(r=>{ inner += `<div style="margin-left:8px" class="small"><b>${escapeHtml(r.author)}</b>: ${escapeHtml(r.text)}</div>`; });
      inner += `</div>`;
    }
    d.innerHTML = inner;
    area.appendChild(d);
  });
}
async function createThread(){
  const title = el("#threadTitle").value.trim();
  const text = el("#threadBody").value.trim();
  if (!title || !text) return alert("Enter title and text");
  if (!SERVER_URL) return alert("Server not configured (tunnel.txt missing).");
  try {
    const data = await serverFetchRoom();
    data.threads = data.threads || [];
    data.threads.unshift({ id: Date.now(), author: currentUser.username || "You", title, text, replies: [], time: new Date().toLocaleString() });
    await serverSaveRoom(data);
    await refreshThreads();
  } catch(e){ alert("Could not create thread (server error)."); console.error(e); }
}
async function replyThread(id){
  const txt = prompt("Reply:"); if (!txt) return;
  if (!SERVER_URL) return alert("Server not configured (tunnel.txt missing).");
  try {
    const data = await serverFetchRoom();
    data.threads = data.threads || [];
    const t = data.threads.find(x=>x.id===id);
    if (!t) return alert("Thread not found on server.");
    t.replies = t.replies || [];
    t.replies.push({ author: currentUser.username || "You", text: txt, time: new Date().toLocaleTimeString() });
    await serverSaveRoom(data);
    await refreshThreads();
  } catch(e){ alert("Could not reply (server error)."); console.error(e); }
}

/* =============== DMs (local only) =============== */
function loadDMList(){
  if (!ensureSignedIn()) return;
  const dms = loadLocal(LOCAL_DMS, {});
  const area = el("#contentArea");
  let html = `<div class="feedPost"><h3>Messages</h3>`;
  const users = Object.keys(dms).sort();
  if (users.length === 0) html += `<div class="small">No conversations yet</div>`;
  for (const u of users){
    const unread = dms[u].some(m => !m.read) ? " üî¥" : "";
    html += `<div style="margin-bottom:6px"><a href="#" onclick="openDM('${escapeAttr(u)}');return false">@${escapeHtml(u)}</a>${unread}</div>`;
  }
  html += `<div style="margin-top:8px"><input id="newDMUser" placeholder="User"><button class="action" onclick="openNewDM()">Start Chat</button></div>`;
  html += `</div>`;
  area.innerHTML = html;
}
function openNewDM(){ const u = el("#newDMUser").value.trim(); if (!u) return alert("Enter username"); openDM(u); }
function openDM(user){
  if (!ensureSignedIn()) return;
  const dms = loadLocal(LOCAL_DMS, {});
  dms[user] = dms[user] || [];
  dms[user].forEach(m=>m.read = true);
  saveLocal(LOCAL_DMS, dms);
  let html = `<div class="feedPost"><h3>Chat ‚Äî @${escapeHtml(user)}</h3><div id="dmMsgs" style="height:300px;overflow-y:auto;border:1px solid #333;padding:6px">`;
  dms[user].forEach(m => html += `<div style="margin-bottom:6px"><b>${escapeHtml(m.from)}</b>: ${escapeHtml(m.text)} <div class="small">${escapeHtml(m.time||"")}</div></div>`);
  html += `</div><div style="margin-top:8px"><input id="dmText" placeholder="Message" style="width:70%"><button class="action" onclick="sendDM('${escapeAttr(user)}')">Send</button> <button onclick="loadDMList()">‚Üê Back</button></div></div>`;
  el("#contentArea").innerHTML = html;
}
function sendDM(user){
  const txt = el("#dmText").value.trim(); if (!txt) return;
  const dms = loadLocal(LOCAL_DMS, {});
  dms[user] = dms[user] || [];
  dms[user].push({ from: currentUser.username || "You", to: user, text: txt, time: new Date().toLocaleTimeString(), read: false });
  saveLocal(LOCAL_DMS, dms);
  openDM(user);
}

/* =============== Profile UI (save to server/users map) =============== */
async function loadProfile(){
  if (!ensureSignedIn()) return;
  // ensure usersMap current
  usersMap = usersMap || loadLocal(USERS_KEY, {});
  const u = currentUser || loadLocal(PROFILE_KEY, {});
  el("#contentArea").innerHTML = `
    <div class="feedPost" style="text-align:center">
      <h3>Your Profile</h3>
      <img id="profileAvatar" src="${escapeAttr(u.avatar || 'https://via.placeholder.com/100')}" style="width:100px;height:100px;border-radius:50%;object-fit:cover"><br>
      <input type="file" id="avatarUpload" accept="image/*" style="margin-top:8px">
      <p><b>Username</b><br><input id="profileName" value="${escapeAttr(u.username||'')}" style="width:60%"></p>
      <p><b>Password</b><br><input id="profilePass" type="password" value="${escapeAttr(u.password||'')}" style="width:60%"></p>
      <p><b>Bio</b><br><textarea id="profileBio" style="width:80%;height:80px">${escapeHtml(u.bio||'')}</textarea></p>
      <div style="margin-top:8px"><button class="action" onclick="saveProfile()">Save</button></div>
    </div>
  `;
  el("#avatarUpload").onchange = async e => {
    const f = e.target.files[0]; if (!f) return;
    const d = await fileToDataURL(f);
    el("#profileAvatar").src = d;
    currentUser.avatar = d;
  };
}

async function saveProfile(){
  // update currentUser object
  currentUser = currentUser || {};
  currentUser.username = el("#profileName").value.trim() || "You";
  currentUser.password = el("#profilePass").value || "";
  currentUser.bio = el("#profileBio").value.trim();
  // avatar already set if user uploaded
  saveLocal(PROFILE_KEY, currentUser);
  // update usersMap
  usersMap = usersMap || loadLocal(USERS_KEY, {});
  usersMap[currentUser.username] = usersMap[currentUser.username] || {};
  usersMap[currentUser.username].password = currentUser.password;
  usersMap[currentUser.username].bio = currentUser.bio;
  usersMap[currentUser.username].avatar = currentUser.avatar || usersMap[currentUser.username].avatar || "";
  saveLocal(USERS_KEY, usersMap);
  // attempt to save both to server (best-effort)
  const uok = await saveServerKey(USERS_KEY, usersMap);
  const pok = await saveServerKey(PROFILE_KEY, currentUser);
  if (!uok || !pok) alert("Saved locally ‚Äî failed to update server (server unreachable).");
  else { alert("Profile saved (server updated)."); }
  setSignedInUI();
}

/* open other user's profile (mini timeline) */
function openProfile(username){
  const posts = allFeedPosts.filter(p => p.author === username);
  let html = `<div class="feedPost" style="text-align:center"><h3>@${escapeHtml(username)}</h3><p class="small">User profile</p><button onclick="switchTab('feed')">‚Üê Back</button></div>`;
  posts.forEach(p => html += makeMiniPostHTML(p));
  el("#contentArea").innerHTML = html;
}
function makeMiniPostHTML(p){
  const div = document.createElement("div"); div.className="feedPost";
  let inner = `<div>${escapeHtml(p.text||"")}</div><div class="small">${escapeHtml(p.time||"")}</div>`;
  div.innerHTML = inner;
  return div.outerHTML;
}

/* =============== Navigation =============== */
function switchTab(tab){
  if (!ensureSignedIn()) return;
  qAll("#navTabs button").forEach(b => b.classList.remove("active"));
  const btn = qAll("#navTabs button").find(b => (b.getAttribute("data-tab")||b.textContent.toLowerCase()) === tab);
  if (btn) btn.classList.add("active");
  if (tab === "feed") loadFeed();
  else if (tab === "threads") loadThreads();
  else if (tab === "messages") loadDMList();
  else if (tab === "profile") loadProfile();
}

/* =============== Initialization =============== */
(async function init(){
  await loadConfig();
  // Attempt to load server-stored profile/users/localPosts and mirror to localStorage.
  // If server unavailable, fall back to localStorage.
  let srvUsers = null, srvProfile = null, srvLocalPosts = null;
  try {
    if (SERVER_URL) {
      srvUsers = await loadServerKey(USERS_KEY);
      srvProfile = await loadServerKey(PROFILE_KEY);
      srvLocalPosts = await loadServerKey(LOCAL_POSTS);
    }
  } catch(e){ console.warn("Server fetch keys failed at init:", e); }

  if (srvUsers) { usersMap = srvUsers; saveLocal(USERS_KEY, usersMap); } else { usersMap = loadLocal(USERS_KEY, {}); }
  if (srvProfile) { currentUser = srvProfile; saveLocal(PROFILE_KEY, currentUser); } else { currentUser = loadLocal(PROFILE_KEY, null); }
  if (Array.isArray(srvLocalPosts)) { localPosts = srvLocalPosts; saveLocal(LOCAL_POSTS, localPosts); } else { localPosts = loadLocal(LOCAL_POSTS, []); }

  setSignedInUI();

  // If no signed-in user, show auth overlay; otherwise open feed or ?post param
  if (!currentUser || !currentUser.username) {
    showAuthOverlay();
  } else {
    // ensure users map has this user
    usersMap[currentUser.username] = usersMap[currentUser.username] || {};
    usersMap[currentUser.username].password = currentUser.password || usersMap[currentUser.username].password || "";
    usersMap[currentUser.username].bio = currentUser.bio || usersMap[currentUser.username].bio || "";
    usersMap[currentUser.username].avatar = currentUser.avatar || usersMap[currentUser.username].avatar || "";
    saveLocal(USERS_KEY, usersMap);
    // save server copies if possible
    await saveServerKey(USERS_KEY, usersMap).catch(()=>{});
    await saveServerKey(PROFILE_KEY, currentUser).catch(()=>{});
    // open ?post parameter if present
    const params = new URLSearchParams(window.location.search);
    if (params.has("post")) {
      await refreshFeed();
      const pid = Number(params.get("post"));
      if (!isNaN(pid)) openPost(pid);
      else loadFeed();
    } else {
      switchTab("feed");
    }
  }
})();

/* expose some functions used inline */
window.openProfile = openProfile;
window.openPost = openPost;
window.replyThread = replyThread;
window.refreshFeed = refreshFeed;
window.refreshThreads = refreshThreads;

</script>
</body>
</html>
